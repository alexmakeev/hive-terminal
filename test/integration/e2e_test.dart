/// End-to-end integration tests for Hive Terminal
///
/// Requires running:
/// - Hive Server on localhost:50051
/// - SSH container on localhost:2222 (testuser:testpass)
/// - PostgreSQL on localhost:5432
///
/// Run with: flutter test test/integration/e2e_test.dart --tags=e2e
@Tags(['e2e'])
library;

import 'dart:async';

import 'package:flutter_test/flutter_test.dart';
import 'package:hive_terminal/core/hive/hive_client.dart';
import 'package:hive_terminal/core/hive/hive_connections_service.dart';
import 'package:hive_terminal/core/hive/hive_terminal_service.dart';
import 'package:hive_terminal/features/connection/connection_config.dart';
import 'package:hive_terminal/src/generated/hive.pbgrpc.dart';

void main() {
  // Test configuration
  const serverHost = 'localhost';
  const serverPort = 50051;
  const sshHost = 'localhost';
  const sshPort = 2222;
  const sshUser = 'testuser';
  const sshPass = 'testpass';
  // API key for e2e-test-user (SHA256: c83662a5...)
  const testApiKey = 'e2e-test-api-key';

  late HiveClient client;

  setUpAll(() async {
    // Connect to Hive Server
    client = HiveClient(host: serverHost, port: serverPort);
    await client.connect();
    // Set API key and validate to get user ID
    client.setApiKey(testApiKey);
    final authResponse = await client.auth.validateApiKey(
      ApiKeyRequest(apiKey: testApiKey),
    );
    if (authResponse.valid && authResponse.userId.isNotEmpty) {
      client.setUserId(authResponse.userId);
    }
  });

  tearDownAll(() async {
    await client.shutdown();
  });

  group('E2E: Server connection', () {
    test('connects to Hive Server', () {
      expect(client.isConnected, isTrue);
    });

    test('auth service is available', () async {
      // Just check that auth client exists
      expect(client.auth, isNotNull);
    });
  });

  group('E2E: API Key validation', () {
    test('validates valid API key', () async {
      final response = await client.auth.validateApiKey(
        ApiKeyRequest(apiKey: testApiKey),
      );

      expect(response.valid, isTrue);
    });

    test('rejects invalid API key', () async {
      final response = await client.auth.validateApiKey(
        ApiKeyRequest(apiKey: 'invalid-test-key'),
      );

      expect(response.valid, isFalse);
    });
  });

  group('E2E: Connections CRUD', () {
    late HiveConnectionsService connectionsService;
    String? connectionId;

    setUpAll(() {
      connectionsService = HiveConnectionsService(client: client);
    });

    test('creates connection for SSH server', () async {
      final config = ConnectionConfig(
        id: '', // Will be generated by server
        name: 'E2E Test SSH',
        host: sshHost,
        port: sshPort,
        username: sshUser,
        password: sshPass,
      );

      final created = await connectionsService.create(config);

      expect(created, isNotNull);
      expect(created!.name, 'E2E Test SSH');
      expect(created.host, sshHost);
      expect(created.port, sshPort);
      expect(created.username, sshUser);

      connectionId = created.id;
    });

    test('lists connections', () async {
      expect(connectionId, isNotNull, reason: 'Connection should be created first');

      await connectionsService.load();

      expect(connectionsService.connections, isNotEmpty);
      expect(
        connectionsService.connections.any((c) => c.id == connectionId),
        isTrue,
      );
    });

    test('updates connection', () async {
      expect(connectionId, isNotNull, reason: 'Connection should be created first');

      final updated = await connectionsService.update(ConnectionConfig(
        id: connectionId!,
        name: 'E2E Test SSH Updated',
        host: sshHost,
        port: sshPort,
        username: sshUser,
      ));

      expect(updated, isNotNull);
      expect(updated!.name, 'E2E Test SSH Updated');
    });

    test('deletes connection', () async {
      expect(connectionId, isNotNull, reason: 'Connection should be created first');

      final deleted = await connectionsService.delete(connectionId!);
      expect(deleted, isTrue);
      connectionId = null;
    });
  });

  group('E2E: Terminal session', () {
    test('full terminal lifecycle: create, attach, command, close', () async {
      final connectionsService = HiveConnectionsService(client: client);
      final terminalService = HiveTerminalService(client: client);

      // Create test connection
      final connection = await connectionsService.create(ConnectionConfig(
        id: '',
        name: 'E2E Terminal Test',
        host: sshHost,
        port: sshPort,
        username: sshUser,
        password: sshPass,
      ));
      expect(connection, isNotNull);

      try {
        // Create session (pass password for SSH authentication)
        final session = await terminalService.createSession(
          connection!.id,
          password: sshPass,
        );
        expect(session, isNotNull);
        expect(session!.id, isNotEmpty);

        // Attach to terminal
        final stream = terminalService.attach(session.id);
        expect(stream, isNotNull);

        // Send initial message to establish connection
        stream!.sendData([]);

        final buffer = StringBuffer();
        final completer = Completer<String>();

        final subscription = stream.output.listen(
          (output) {
            if (HiveTerminalService.isData(output)) {
              buffer.write(String.fromCharCodes(output.data));
              if (buffer.toString().contains('E2E_TERMINAL_MARKER')) {
                if (!completer.isCompleted) {
                  completer.complete(buffer.toString());
                }
              }
            }
          },
          onError: (e) {
            if (!completer.isCompleted) {
              completer.completeError(e);
            }
          },
        );

        // Wait for shell
        await Future.delayed(const Duration(seconds: 2));

        // Send command
        stream.sendData('echo "E2E_TERMINAL_MARKER"\n'.codeUnits);

        // Wait for output
        final output = await completer.future.timeout(
          const Duration(seconds: 15),
          onTimeout: () => buffer.toString(),
        );

        await subscription.cancel();
        await stream.close();

        expect(output, contains('E2E_TERMINAL_MARKER'));

        // Close session
        final closed = await terminalService.closeSession(session.id);
        expect(closed, isTrue);
      } finally {
        // Clean up connection
        if (connection != null) {
          await connectionsService.delete(connection.id);
        }
      }
    });
  });

  group('E2E: Terminal resize', () {
    late HiveConnectionsService connectionsService;
    late HiveTerminalService terminalService;
    String? connectionId;
    String? sessionId;

    setUp(() async {
      connectionsService = HiveConnectionsService(client: client);
      terminalService = HiveTerminalService(client: client);

      final created = await connectionsService.create(ConnectionConfig(
        id: '', // Will be generated by server
        name: 'E2E Resize Test',
        host: sshHost,
        port: sshPort,
        username: sshUser,
        password: sshPass,
      ));
      connectionId = created?.id;

      final session = await terminalService.createSession(
        connectionId!,
        password: sshPass,
      );
      sessionId = session?.id;
    });

    test('sends resize event', () async {
      expect(sessionId, isNotNull);

      final stream = terminalService.attach(sessionId!);
      expect(stream, isNotNull);

      // Wait for connection
      await Future.delayed(const Duration(milliseconds: 500));

      // Send resize event (should not throw)
      stream!.sendResize(120, 40);

      // Give server time to process
      await Future.delayed(const Duration(milliseconds: 200));

      await stream.close();

      // If we got here without error, test passes
      expect(true, isTrue);
    });

    tearDown(() async {
      if (sessionId != null) {
        await terminalService.closeSession(sessionId!);
      }
      if (connectionId != null) {
        await connectionsService.delete(connectionId!);
      }
    });
  });
}
